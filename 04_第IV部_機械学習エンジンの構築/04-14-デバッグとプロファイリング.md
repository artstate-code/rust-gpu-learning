[ğŸ“š ç›®æ¬¡](../README.md) | [â¬…ï¸ ç¬¬13ç« ](04-13-å­¦ç¿’ãƒ«ãƒ¼ãƒ—ã¨æœ€é©åŒ–æ‰‹æ³•.md) | [â¡ï¸ ç¬¬15ç« ](../05_ç¬¬Véƒ¨_å¿œç”¨ã¨é«˜åº¦åŒ–/05-15-ãƒ¢ãƒ‡ãƒ«æ¨è«–ã¨ONNXäº’æ›.md)

---

# ç¬¬ 11 ç« ã€€ãƒ‡ãƒãƒƒã‚°ã¨ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒªãƒ³ã‚°

ã“ã®ç« ã§ã¯ã€GPUæ©Ÿæ¢°å­¦ç¿’ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®ãƒ‡ãƒãƒƒã‚°ã¨ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒªãƒ³ã‚°æŠ€è¡“ã‚’å­¦ã³ã¾ã™ã€‚CUDA Profilerã€NSight Systemsã€Rustå›ºæœ‰ã®ãƒ„ãƒ¼ãƒ«ï¼ˆcargo-flamegraphã€valgrindï¼‰ã‚’ä½¿ã£ã¦ã€ãƒœãƒˆãƒ«ãƒãƒƒã‚¯ã®ç™ºè¦‹ã‹ã‚‰æœ€é©åŒ–ã¾ã§ã®å®Ÿè·µçš„ãªæ‰‹æ³•ã‚’ç¿’å¾—ã—ã¾ã™ã€‚

**ç›®çš„**: ãƒ—ãƒ­ãƒ€ã‚¯ã‚·ãƒ§ãƒ³ç’°å¢ƒã§é«˜æ€§èƒ½ãªRust+GPUæ©Ÿæ¢°å­¦ç¿’ã‚·ã‚¹ãƒ†ãƒ ã‚’æ§‹ç¯‰ãƒ»é‹ç”¨ã™ã‚‹ãŸã‚ã®å®Ÿè·µçš„ã‚¹ã‚­ãƒ«ã‚’èº«ã«ã¤ã‘ã¾ã™ã€‚

## 11.1 æ•°å€¤è¨ˆç®—ã®æ¤œè¨¼ï¼ˆPythonå‡ºåŠ›ã¨ã®æ¯”è¼ƒï¼‰

### æ•°å€¤æ¤œè¨¼ã®é‡è¦æ€§

æ©Ÿæ¢°å­¦ç¿’ã§ã¯ã€å¾®å°ãªæ•°å€¤èª¤å·®ãŒå­¦ç¿’ã®å¤±æ•—ã‚’æ‹›ãã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚Rustå®Ÿè£…ã¨Pythonï¼ˆNumPy/PyTorchï¼‰å®Ÿè£…ã‚’**ãƒ“ãƒƒãƒˆå˜ä½ã§æ¯”è¼ƒ**ã™ã‚‹ã“ã¨ãŒé‡è¦ã§ã™ã€‚

### æ¤œè¨¼ã®æˆ¦ç•¥

```mermaid
graph TD
    Start([æ¤œè¨¼é–‹å§‹]) --> Unit[ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆ<br/>å€‹åˆ¥ã‚ªãƒšãƒ¬ãƒ¼ã‚¿]
    Unit --> Integration[çµ±åˆãƒ†ã‚¹ãƒˆ<br/>Forward/Backward]
    Integration --> E2E[E2Eãƒ†ã‚¹ãƒˆ<br/>å­¦ç¿’å…¨ä½“]
    
    Unit --> Check1{ä¸€è‡´?}
    Check1 -->|Yes| Integration
    Check1 -->|No| Debug1[ãƒ‡ãƒãƒƒã‚°<br/>æµ®å‹•å°æ•°ç‚¹èª¤å·®ç¢ºèª]
    
    Integration --> Check2{ä¸€è‡´?}
    Check2 -->|Yes| E2E
    Check2 -->|No| Debug2[ãƒ‡ãƒãƒƒã‚°<br/>è¨ˆç®—ã‚°ãƒ©ãƒ•ç¢ºèª]
    
    E2E --> Check3{åæŸ?}
    Check3 -->|Yes| Done([å®Œäº†])
    Check3 -->|No| Debug3[ãƒ‡ãƒãƒƒã‚°<br/>å­¦ç¿’ç‡ãƒ»å‹¾é…ç¢ºèª]
    
    style Check1 fill:#ffe1e1
    style Check2 fill:#ffe1e1
    style Check3 fill:#ffe1e1
    style Done fill:#e1ffe1
```

### Pythonï¼ˆNumPyï¼‰ã¨ã®æ¯”è¼ƒ

**Python ã‚³ãƒ¼ãƒ‰**:

```python
import numpy as np

# ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ç”Ÿæˆ
np.random.seed(42)
x = np.random.randn(128, 784).astype(np.float32)
w = np.random.randn(784, 256).astype(np.float32)
b = np.random.randn(256).astype(np.float32)

# Forward
y = x @ w + b

# ReLU
y_relu = np.maximum(0, y)

# å‡ºåŠ›ã‚’ä¿å­˜
np.save('test_output.npy', y_relu)

print(f"Shape: {y_relu.shape}")
print(f"Mean: {y_relu.mean():.6f}")
print(f"Std: {y_relu.std():.6f}")
print(f"Min: {y_relu.min():.6f}")
print(f"Max: {y_relu.max():.6f}")
```

**Rust ã‚³ãƒ¼ãƒ‰**:

```rust
use ndarray::{Array1, Array2};
use ndarray_npy::read_npy;

fn test_against_python() {
    // Python ã¨åŒã˜ä¹±æ•°ç”Ÿæˆ
    let mut rng = StdRng::seed_from_u64(42);
    let x = Array2::random_using((128, 784), StandardNormal, &mut rng);
    let w = Array2::random_using((784, 256), StandardNormal, &mut rng);
    let b = Array1::random_using(256, StandardNormal, &mut rng);
    
    // Forward
    let y = x.dot(&w) + &b;
    
    // ReLU
    let y_relu = y.mapv(|v| v.max(0.0));
    
    // Pythonå‡ºåŠ›ã‚’èª­ã¿è¾¼ã¿
    let y_python: Array2<f32> = read_npy("test_output.npy").unwrap();
    
    // æ¯”è¼ƒ
    let diff = (&y_relu - &y_python).mapv(|v| v.abs());
    let max_diff = diff.iter().cloned().fold(f32::NEG_INFINITY, f32::max);
    let mean_diff = diff.mean().unwrap();
    
    println!("Max diff: {:.8e}", max_diff);
    println!("Mean diff: {:.8e}", mean_diff);
    
    // è¨±å®¹èª¤å·®å†…ã‹ãƒã‚§ãƒƒã‚¯
    assert!(max_diff < 1e-5, "Difference too large: {:.8e}", max_diff);
}
```

### æµ®å‹•å°æ•°ç‚¹èª¤å·®ã®è¨±å®¹ç¯„å›²

| æ¼”ç®— | è¨±å®¹èª¤å·®ï¼ˆç›¸å¯¾ï¼‰ | è¨±å®¹èª¤å·®ï¼ˆçµ¶å¯¾ï¼‰ | ç†ç”± |
|------|----------------|----------------|------|
| **åŠ ç®—/æ¸›ç®—** | $10^{-7}$ (FP32) | $10^{-7}$ | æ¡è½ã¡ |
| **ä¹—ç®—** | $10^{-7}$ | $10^{-6}$ | ä¸¸ã‚èª¤å·® |
| **è¡Œåˆ—ç©** | $10^{-6}$ | $10^{-5}$ | ç´¯ç©èª¤å·® |
| **Softmax** | $10^{-5}$ | $10^{-4}$ | æŒ‡æ•°é–¢æ•°ã®èª¤å·® |
| **Backward** | $10^{-4}$ | $10^{-3}$ | èª¤å·®ã®ä¼æ’­ |

**ç›¸å¯¾èª¤å·®**ã®è¨ˆç®—:

$$
\text{Relative Error} = \frac{|y_{\text{rust}} - y_{\text{python}}|}{|y_{\text{python}}| + \epsilon}
$$

### æ•°å€¤çš„å‹¾é…ãƒã‚§ãƒƒã‚¯ï¼ˆGradient Checkingï¼‰

**ç†è«–**: æ•°å€¤å¾®åˆ† vs è‡ªå‹•å¾®åˆ†

$$
\frac{\partial f}{\partial x} \approx \frac{f(x + h) - f(x - h)}{2h}
$$

**Python ã‚³ãƒ¼ãƒ‰**:

```python
def numerical_gradient(f, x, h=1e-5):
    grad = np.zeros_like(x)
    it = np.nditer(x, flags=['multi_index'])
    
    while not it.finished:
        idx = it.multi_index
        old_value = x[idx]
        
        # f(x+h)
        x[idx] = old_value + h
        fxh1 = f(x)
        
        # f(x-h)
        x[idx] = old_value - h
        fxh2 = f(x)
        
        # ä¸­å¿ƒå·®åˆ†
        grad[idx] = (fxh1 - fxh2) / (2 * h)
        
        x[idx] = old_value
        it.iternext()
    
    return grad

# ãƒ†ã‚¹ãƒˆ
def loss_fn(w):
    y = x @ w
    return np.sum((y - target) ** 2)

# è‡ªå‹•å¾®åˆ†
w.grad = None
loss = loss_fn(w)
loss.backward()
auto_grad = w.grad.numpy()

# æ•°å€¤å¾®åˆ†
numerical_grad = numerical_gradient(loss_fn, w.detach().numpy())

# æ¯”è¼ƒ
diff = np.abs(auto_grad - numerical_grad)
print(f"Max diff: {diff.max():.8e}")
assert diff.max() < 1e-5
```

**Rust ã‚³ãƒ¼ãƒ‰**:

```rust
fn numerical_gradient<F>(f: F, x: &Array2<f32>, h: f32) -> Array2<f32>
where
    F: Fn(&Array2<f32>) -> f32,
{
    let mut grad = Array2::zeros(x.raw_dim());
    
    for i in 0..x.nrows() {
        for j in 0..x.ncols() {
            let old_value = x[[i, j]];
            
            // f(x+h)
            let mut x_plus = x.clone();
            x_plus[[i, j]] = old_value + h;
            let fxh1 = f(&x_plus);
            
            // f(x-h)
            let mut x_minus = x.clone();
            x_minus[[i, j]] = old_value - h;
            let fxh2 = f(&x_minus);
            
            // ä¸­å¿ƒå·®åˆ†
            grad[[i, j]] = (fxh1 - fxh2) / (2.0 * h);
        }
    }
    
    grad
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_gradient() {
        let x = Array2::random((10, 10), StandardNormal);
        let target = Array2::random((10, 10), StandardNormal);
        
        // æå¤±é–¢æ•°
        let loss_fn = |w: &Array2<f32>| {
            let y = x.dot(w);
            (&y - &target).mapv(|v| v * v).sum()
        };
        
        // è‡ªå‹•å¾®åˆ†ï¼ˆå®Ÿè£…æ¸ˆã¿ã®backwardï¼‰
        let auto_grad = compute_auto_gradient(&x, &target);
        
        // æ•°å€¤å¾®åˆ†
        let numerical_grad = numerical_gradient(loss_fn, &x, 1e-5);
        
        // æ¯”è¼ƒ
        let diff = (&auto_grad - &numerical_grad).mapv(|v| v.abs());
        let max_diff = diff.iter().cloned().fold(f32::NEG_INFINITY, f32::max);
        
        assert!(max_diff < 1e-4, "Gradient check failed: {:.8e}", max_diff);
    }
}
```

## 11.2 GPU ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒªãƒ³ã‚°ï¼ˆNVIDIA Nsight, rocm-profilerï¼‰

### NVIDIA Nsight Systems

**Nsight Systems** [^1] ã¯ã€CUDA ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã® CPU/GPU ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³ã‚’å¯è¦–åŒ–ã—ã¾ã™ã€‚

[^1]: NVIDIA Nsight Systems. https://developer.nvidia.com/nsight-systems

**ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«**:

```bash
# Ubuntu
wget https://developer.download.nvidia.com/devtools/nsight-systems/2023.3.1/NsightSystems-linux-2023.3.1.deb
sudo dpkg -i NsightSystems-*.deb

# ç¢ºèª
nsys --version
```

**ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒªãƒ³ã‚°å®Ÿè¡Œ**:

```bash
# Rustãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«
nsys profile \
    --trace=cuda,nvtx,osrt \
    --output=rust_ml_profile \
    --force-overwrite=true \
    ./target/release/rust_ml_training

# ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆ
nsys stats rust_ml_profile.qdrep
```

**å‡ºåŠ›ä¾‹**:

```
CUDA Kernel Statistics:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Kernel Name             â”‚ Calls â”‚ Total (ms) â”‚ Avg (ms)  â”‚ Bandwidth   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ matmul_kernel           â”‚ 1000  â”‚ 523.4      â”‚ 0.523     â”‚ 1234 GB/s   â”‚
â”‚ relu_kernel             â”‚ 1000  â”‚ 45.2       â”‚ 0.045     â”‚ 2100 GB/s   â”‚
â”‚ softmax_kernel          â”‚ 1000  â”‚ 78.9       â”‚ 0.079     â”‚ 890 GB/s    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Memory Operations:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Operation       â”‚ Total (GB)   â”‚ Time (ms)  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ H2D (Hostâ†’GPU)  â”‚ 12.5         â”‚ 156.2      â”‚
â”‚ D2H (GPUâ†’Host)  â”‚ 0.3          â”‚ 8.9        â”‚
â”‚ D2D (GPUå†…)     â”‚ 45.7         â”‚ 234.1      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**NVTX ãƒãƒ¼ã‚«ãƒ¼ã®è¿½åŠ **:

```rust
use nvtx::range_push;
use nvtx::range_pop;

pub fn train_epoch() {
    range_push!("train_epoch");
    
    for batch in data_loader {
        range_push!("forward");
        let output = model.forward(&batch.x);
        range_pop!();
        
        range_push!("loss");
        let loss = criterion.forward(&output, &batch.y);
        range_pop!();
        
        range_push!("backward");
        model.backward(&loss);
        range_pop!();
        
        range_push!("optimizer_step");
        optimizer.step();
        range_pop!();
    }
    
    range_pop!();
}
```

### NVIDIA Nsight Compute

**Nsight Compute** [^2] ã¯ã€å€‹åˆ¥ã‚«ãƒ¼ãƒãƒ«ã®è©³ç´°ãªè§£æã‚’è¡Œã„ã¾ã™ã€‚

[^2]: NVIDIA Nsight Compute. https://developer.nvidia.com/nsight-compute

**å®Ÿè¡Œ**:

```bash
ncu --set full \
    --export=matmul_analysis \
    --kernel-name=matmul_kernel \
    ./target/release/rust_ml_training
```

**è§£æé …ç›®**:

| ãƒ¡ãƒˆãƒªãƒƒã‚¯ | èª¬æ˜ | ç›®æ¨™å€¤ |
|-----------|------|--------|
| **Achieved Occupancy** | SMå æœ‰ç‡ | > 50% |
| **Memory Throughput** | ãƒ¡ãƒ¢ãƒªå¸¯åŸŸä½¿ç”¨ç‡ | > 80% |
| **Compute Throughput** | æ¼”ç®—å™¨ä½¿ç”¨ç‡ | > 60% |
| **Warp Execution Efficiency** | Warpå®Ÿè¡ŒåŠ¹ç‡ | > 90% |
| **Branch Efficiency** | åˆ†å²åŠ¹ç‡ | > 95% |

**å‡ºåŠ›ä¾‹**:

```
Kernel: matmul_kernel
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
Section: GPU Speed of Light Throughput
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
Memory Throughput     78.4% â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘  Good
Compute Throughput    45.2% â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘  Low

âš  Suggestion: Kernel is memory-bound. Consider:
  1. Increasing arithmetic intensity
  2. Using shared memory
  3. Improving memory coalescing

Section: Memory Workload Analysis
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
L1/TEX Cache Hit Rate:        23.4%  âš  Low
L2 Cache Hit Rate:            65.8%  âœ“ Good
Global Load Efficiency:       78.9%  âœ“ Good
Global Store Efficiency:      91.2%  âœ“ Good
```

### ROCm Profilerï¼ˆAMD GPUï¼‰

**ROCm** [^3] ã§ã®ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒªãƒ³ã‚°:

[^3]: ROCm Profiler. https://github.com/ROCm-Developer-Tools/rocprofiler

```bash
# ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«
sudo apt install rocprofiler

# ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒªãƒ³ã‚°
rocprof --stats --hip-trace ./target/release/rust_ml_training

# çµæœè¡¨ç¤º
cat results.stats.csv
```

## 11.3 CPU ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒªãƒ³ã‚°ï¼ˆcargo-flamegraph, perfï¼‰

### Flamegraph

**Flamegraph** [^4] ã¯ã€CPUä½¿ç”¨æ™‚é–“ã‚’å¯è¦–åŒ–ã—ã¾ã™ã€‚

[^4]: Flame Graphs. http://www.brendangregg.com/flamegraphs.html

**ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«**:

```bash
cargo install flamegraph
```

**å®Ÿè¡Œ**:

```bash
# ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒªãƒ³ã‚°ï¼ˆrootæ¨©é™ãŒå¿…è¦ãªå ´åˆï¼‰
cargo flamegraph --bin rust_ml_training

# å‡ºåŠ›: flamegraph.svg
```

**Flamegraph ã®èª­ã¿æ–¹**:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ main (100%)                                                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ train_loop (85%)                    â”‚ other (15%)             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                         â”‚
â”‚ forward (40%)â”‚ backward (35%)       â”‚ optimizer (10%)         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

- **å¹…**: CPUæ™‚é–“ã®å‰²åˆ
- **é«˜ã•**: ã‚³ãƒ¼ãƒ«ã‚¹ã‚¿ãƒƒã‚¯ã®æ·±ã•
- **è‰²**: ãƒ©ãƒ³ãƒ€ãƒ ï¼ˆç‰¹ã«æ„å‘³ãªã—ï¼‰

### perfï¼ˆLinuxï¼‰

**perf** [^5] ã¯ã€Linuxã‚«ãƒ¼ãƒãƒ«ã®ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒªãƒ³ã‚°ãƒ„ãƒ¼ãƒ«ã§ã™ã€‚

[^5]: perf: Linux profiling with performance counters. https://perf.wiki.kernel.org/

```bash
# ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒªãƒ³ã‚°
perf record -g ./target/release/rust_ml_training

# ãƒ¬ãƒãƒ¼ãƒˆè¡¨ç¤º
perf report

# ã‚¢ãƒãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰å˜ä½ï¼‰
perf annotate
```

**å‡ºåŠ›ä¾‹**:

```
Samples: 45K of event 'cycles', Event count (approx.): 38547283940
Overhead  Command          Shared Object       Symbol
  42.35%  rust_ml_training rust_ml_training    [.] matmul_naive
  18.72%  rust_ml_training libopenblas.so.0    [.] dgemm_
  12.45%  rust_ml_training rust_ml_training    [.] backward_linear
   8.93%  rust_ml_training rust_ml_training    [.] sgd_update
   ...
```

### CPU ãƒ›ãƒƒãƒˆã‚¹ãƒãƒƒãƒˆã®æœ€é©åŒ–ä¾‹

**Before**:

```rust
// éåŠ¹ç‡ãªå®Ÿè£…
pub fn matmul_naive(a: &Array2<f32>, b: &Array2<f32>) -> Array2<f32> {
    let (m, k) = a.dim();
    let (_, n) = b.dim();
    let mut c = Array2::zeros((m, n));
    
    for i in 0..m {
        for j in 0..n {
            for p in 0..k {
                c[[i, j]] += a[[i, p]] * b[[p, j]];  // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒŸã‚¹å¤šç™º
            }
        }
    }
    
    c
}
```

**Afterï¼ˆæœ€é©åŒ–ï¼‰**:

```rust
use rayon::prelude::*;

pub fn matmul_optimized(a: &Array2<f32>, b: &Array2<f32>) -> Array2<f32> {
    // BLASãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ä½¿ç”¨
    a.dot(b)
}

// ã¾ãŸã¯ä¸¦åˆ—åŒ–
pub fn matmul_parallel(a: &Array2<f32>, b: &Array2<f32>) -> Array2<f32> {
    let (m, k) = a.dim();
    let (_, n) = b.dim();
    
    // è¡Œã”ã¨ã«ä¸¦åˆ—å‡¦ç†
    let rows: Vec<_> = (0..m)
        .into_par_iter()
        .map(|i| {
            let row = a.row(i);
            let mut result = Array1::zeros(n);
            for j in 0..n {
                result[j] = row.dot(&b.column(j));
            }
            result
        })
        .collect();
    
    ndarray::stack(Axis(0), &rows.iter().map(|r| r.view()).collect::<Vec<_>>()).unwrap()
}
```

**ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æ¯”è¼ƒ**:

| å®Ÿè£… | æ™‚é–“ï¼ˆmsï¼‰ | ã‚¹ãƒ”ãƒ¼ãƒ‰ã‚¢ãƒƒãƒ— |
|------|-----------|--------------|
| `matmul_naive` | 1250 | 1x |
| `matmul_parallel` (4ã‚³ã‚¢) | 340 | 3.7x |
| `matmul_optimized` (OpenBLAS) | 45 | 27.8x |

## 11.4 ãƒ¡ãƒ¢ãƒªãƒªãƒ¼ã‚¯ãƒ»ç«¶åˆæ¤œå‡ºï¼ˆvalgrind, miri, sanitizersï¼‰

### Valgrindï¼ˆMemcheckï¼‰

**Valgrind** [^6] ã¯ã€ãƒ¡ãƒ¢ãƒªã‚¨ãƒ©ãƒ¼ã‚’æ¤œå‡ºã—ã¾ã™ã€‚

[^6]: Valgrind. https://valgrind.org/

```bash
# ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«
sudo apt install valgrind

# å®Ÿè¡Œ
valgrind --leak-check=full \
         --show-leak-kinds=all \
         --track-origins=yes \
         ./target/debug/rust_ml_training
```

**æ¤œå‡ºã§ãã‚‹ã‚¨ãƒ©ãƒ¼**:

| ã‚¨ãƒ©ãƒ¼ | èª¬æ˜ | ä¾‹ |
|--------|------|-----|
| **Memory Leak** | è§£æ”¾ã•ã‚Œãªã„ãƒ¡ãƒ¢ãƒª | `Box::leak` |
| **Use after free** | è§£æ”¾å¾Œã®ã‚¢ã‚¯ã‚»ã‚¹ | `unsafe` ã‚³ãƒ¼ãƒ‰ |
| **Invalid read/write** | ç¯„å›²å¤–ã‚¢ã‚¯ã‚»ã‚¹ | ãƒãƒƒãƒ•ã‚¡ã‚ªãƒ¼ãƒãƒ¼ãƒ•ãƒ­ãƒ¼ |
| **Uninitialized value** | æœªåˆæœŸåŒ–å¤‰æ•°ã®ä½¿ç”¨ | `MaybeUninit` ã®èª¤ç”¨ |

**å‡ºåŠ›ä¾‹**:

```
==12345== Memcheck, a memory error detector
==12345== 
==12345== LEAK SUMMARY:
==12345==    definitely lost: 4,096 bytes in 1 blocks
==12345==    indirectly lost: 0 bytes in 0 blocks
==12345==      possibly lost: 0 bytes in 0 blocks
==12345==    still reachable: 72,704 bytes in 2 blocks
==12345==         suppressed: 0 bytes in 0 blocks
```

### Miriï¼ˆRust Interpreterï¼‰

**Miri** [^7] ã¯ã€Rustã®æœªå®šç¾©å‹•ä½œã‚’æ¤œå‡ºã—ã¾ã™ã€‚

[^7]: Miri. https://github.com/rust-lang/miri

```bash
# ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«
rustup +nightly component add miri

# å®Ÿè¡Œ
cargo +nightly miri test
```

**æ¤œå‡ºã§ãã‚‹æœªå®šç¾©å‹•ä½œ**:

- Out-of-bounds memory accesses
- Use of uninitialized memory
- Invalid pointer arithmetic
- Data raceï¼ˆä¸¦è¡Œãƒ—ãƒ­ã‚°ãƒ©ãƒ ï¼‰

**ä¾‹**:

```rust
#[test]
fn test_unsafe_code() {
    let v = vec![1, 2, 3];
    let ptr = v.as_ptr();
    
    unsafe {
        // ç¯„å›²å¤–ã‚¢ã‚¯ã‚»ã‚¹
        let val = *ptr.add(10);  // âŒ Miri ãŒæ¤œå‡º
    }
}
```

**Miri å‡ºåŠ›**:

```
error: Undefined Behavior: out-of-bounds pointer arithmetic
  --> src/lib.rs:45:23
   |
45 |         let val = *ptr.add(10);
   |                   ^^^^^^^^^^^^ 
   |                   accessing memory at offset 40, 
   |                   but allocation is only 12 bytes
```

### AddressSanitizer / ThreadSanitizer

**AddressSanitizer (ASan)** [^8]:

[^8]: AddressSanitizer. https://github.com/google/sanitizers

```bash
# ãƒ“ãƒ«ãƒ‰
RUSTFLAGS="-Z sanitizer=address" cargo build --target x86_64-unknown-linux-gnu

# å®Ÿè¡Œ
./target/x86_64-unknown-linux-gnu/debug/rust_ml_training
```

**ThreadSanitizer (TSan)**ï¼ˆãƒ‡ãƒ¼ã‚¿ç«¶åˆæ¤œå‡ºï¼‰:

```bash
RUSTFLAGS="-Z sanitizer=thread" cargo +nightly build

./target/debug/rust_ml_training
```

**æ¤œå‡ºä¾‹**:

```rust
use std::sync::Arc;
use std::thread;

fn data_race_example() {
    let data = Arc::new(vec![1, 2, 3]);
    let data_clone = data.clone();
    
    let handle = thread::spawn(move || {
        // âŒ ãƒ‡ãƒ¼ã‚¿ç«¶åˆï¼ˆArcã¯ä¸å¤‰å‚ç…§ã®ã¿ï¼‰
        unsafe {
            let ptr = Arc::as_ptr(&data_clone) as *mut Vec<i32>;
            (*ptr).push(4);
        }
    });
    
    // ãƒ¡ã‚¤ãƒ³ã‚¹ãƒ¬ãƒƒãƒ‰ã‚‚åŒæ™‚ã«ã‚¢ã‚¯ã‚»ã‚¹
    println!("{:?}", data);
    
    handle.join().unwrap();
}
```

**TSan å‡ºåŠ›**:

```
WARNING: ThreadSanitizer: data race (pid=12345)
  Write of size 8 at 0x7b0400000010 by thread T1:
    #0 Vec::push src/lib.rs:123
  
  Previous read of size 8 at 0x7b0400000010 by main thread:
    #0 println! src/lib.rs:126
```

## 11.5 ãƒ†ã‚¹ãƒˆè‡ªå‹•åŒ–ã¨ CI/CD

### ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆã®æ§‹æˆ

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use approx::assert_relative_eq;
    
    #[test]
    fn test_linear_forward() {
        let layer = LinearLayer::new(10, 5);
        let x = Array2::ones((2, 10));
        
        let y = layer.forward(&x);
        
        assert_eq!(y.dim(), (2, 5));
    }
    
    #[test]
    fn test_linear_backward() {
        let mut layer = LinearLayer::new(10, 5);
        let x = Array2::ones((2, 10));
        
        // Forward
        let y = layer.forward(&x);
        
        // Backward
        let grad_out = Array2::ones((2, 5));
        let grad_in = layer.backward(&grad_out);
        
        assert_eq!(grad_in.dim(), (2, 10));
        assert!(layer.grad_weight.is_some());
    }
    
    #[test]
    fn test_numerical_gradient() {
        // æ•°å€¤çš„å‹¾é…ãƒã‚§ãƒƒã‚¯ï¼ˆå‰è¿°ï¼‰
        let layer = LinearLayer::new(5, 3);
        // ... å®Ÿè£… ...
    }
}
```

### ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ãƒ™ãƒ¼ã‚¹ãƒ†ã‚¹ãƒˆï¼ˆproptestï¼‰

**proptest** [^9] ã¯ã€ãƒ©ãƒ³ãƒ€ãƒ ãªå…¥åŠ›ã§ä¸å¤‰æ¡ä»¶ã‚’æ¤œè¨¼ã—ã¾ã™ã€‚

[^9]: proptest. https://github.com/proptest-rs/proptest

```rust
use proptest::prelude::*;

proptest! {
    #[test]
    fn test_relu_properties(x in prop::array::uniform32(-100.0f32..100.0)) {
        let result = relu(&x);
        
        // ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£1: å‡ºåŠ›ã¯å¸¸ã«éè² 
        prop_assert!(result.iter().all(|&v| v >= 0.0));
        
        // ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£2: å˜èª¿æ€§
        for (&input, &output) in x.iter().zip(result.iter()) {
            if input > 0.0 {
                prop_assert_eq!(output, input);
            } else {
                prop_assert_eq!(output, 0.0);
            }
        }
    }
    
    #[test]
    fn test_matmul_dimensions(
        m in 1usize..100,
        n in 1usize..100,
        k in 1usize..100
    ) {
        let a = Array2::<f32>::zeros((m, k));
        let b = Array2::<f32>::zeros((k, n));
        
        let c = matmul(&a, &b);
        
        prop_assert_eq!(c.dim(), (m, n));
    }
}
```

### GitHub Actions ã§ã® CI/CD

`.github/workflows/rust.yml`:

```yaml
name: Rust CI

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Install Rust
      uses: actions-rs/toolchain@v1
      with:
        toolchain: stable
        override: true
    
    - name: Cache cargo
      uses: actions/cache@v3
      with:
        path: |
          ~/.cargo/registry
          ~/.cargo/git
          target
        key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
    
    - name: Run tests
      run: cargo test --all-features
    
    - name: Run clippy
      run: cargo clippy -- -D warnings
    
    - name: Check formatting
      run: cargo fmt -- --check
    
    - name: Run benchmarks
      run: cargo bench --no-run

  miri:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Install Rust nightly + Miri
      uses: actions-rs/toolchain@v1
      with:
        toolchain: nightly
        components: miri
        override: true
    
    - name: Run Miri
      run: cargo +nightly miri test

  coverage:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Install tarpaulin
      run: cargo install cargo-tarpaulin
    
    - name: Generate coverage
      run: cargo tarpaulin --out Xml
    
    - name: Upload to codecov.io
      uses: codecov/codecov-action@v3
      with:
        token: ${{ secrets.CODECOV_TOKEN }}
```

### ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯ï¼ˆCriterionï¼‰

**Criterion** [^10] ã¯ã€çµ±è¨ˆçš„ã«ä¿¡é ¼ã§ãã‚‹ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯ã‚’æä¾›ã—ã¾ã™ã€‚

[^10]: Criterion.rs. https://github.com/bheisler/criterion.rs

```rust
use criterion::{black_box, criterion_group, criterion_main, Criterion};

fn benchmark_matmul(c: &mut Criterion) {
    let a = Array2::<f32>::ones((512, 512));
    let b = Array2::<f32>::ones((512, 512));
    
    c.bench_function("matmul 512x512", |bencher| {
        bencher.iter(|| {
            let result = black_box(&a).dot(black_box(&b));
            black_box(result);
        });
    });
}

fn benchmark_optimizers(c: &mut Criterion) {
    let mut group = c.benchmark_group("optimizers");
    
    let params = vec![Array2::<f32>::ones((1000, 1000))];
    let grads = vec![Array2::<f32>::ones((1000, 1000))];
    
    group.bench_function("SGD", |b| {
        let mut sgd = SGD::new(0.01);
        b.iter(|| {
            sgd.step(&mut params.clone(), &grads);
        });
    });
    
    group.bench_function("Adam", |b| {
        let mut adam = Adam::new(&params, 0.001);
        b.iter(|| {
            adam.step(&mut params.clone(), &grads);
        });
    });
    
    group.finish();
}

criterion_group!(benches, benchmark_matmul, benchmark_optimizers);
criterion_main!(benches);
```

**å®Ÿè¡Œ**:

```bash
cargo bench

# å‡ºåŠ›ä¾‹:
matmul 512x512         time:   [2.3421 ms 2.3654 ms 2.3912 ms]
                       change: [-1.2345% +0.5432% +2.1234%] (p = 0.23)

optimizers/SGD         time:   [123.45 Âµs 125.67 Âµs 128.12 Âµs]
optimizers/Adam        time:   [234.56 Âµs 237.89 Âµs 241.34 Âµs]
```

## 11.6 ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã®ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹

### Result ã¨ ? æ¼”ç®—å­

```rust
use thiserror::Error;

#[derive(Error, Debug)]
pub enum MLError {
    #[error("Shape mismatch: expected {expected:?}, got {actual:?}")]
    ShapeMismatch {
        expected: Vec<usize>,
        actual: Vec<usize>,
    },
    
    #[error("CUDA error: {0}")]
    CudaError(String),
    
    #[error("Numerical instability: {0}")]
    NumericalError(String),
    
    #[error(transparent)]
    IOError(#[from] std::io::Error),
}

pub type Result<T> = std::result::Result<T, MLError>;

impl LinearLayer {
    pub fn forward(&self, x: &Array2<f32>) -> Result<Array2<f32>> {
        let (batch, in_features) = x.dim();
        
        if in_features != self.in_features {
            return Err(MLError::ShapeMismatch {
                expected: vec![batch, self.in_features],
                actual: vec![batch, in_features],
            });
        }
        
        Ok(x.dot(&self.weight.t()) + &self.bias)
    }
}
```

### ãƒ‘ãƒ‹ãƒƒã‚¯ã®å›é¿

```rust
// âŒ Bad: ãƒ‘ãƒ‹ãƒƒã‚¯
pub fn softmax_bad(x: &Array1<f32>) -> Array1<f32> {
    let max = x.iter().cloned().fold(f32::NEG_INFINITY, f32::max);
    let exp_x = x.mapv(|v| (v - max).exp());
    let sum = exp_x.sum();
    
    exp_x / sum  // sum=0 ã®å ´åˆãƒ‘ãƒ‹ãƒƒã‚¯
}

// âœ… Good: Resultã§å‡¦ç†
pub fn softmax_safe(x: &Array1<f32>) -> Result<Array1<f32>> {
    let max = x.iter().cloned().fold(f32::NEG_INFINITY, f32::max);
    let exp_x = x.mapv(|v| (v - max).exp());
    let sum = exp_x.sum();
    
    if sum <= 1e-10 {
        return Err(MLError::NumericalError(
            "Softmax denominator too small".into()
        ));
    }
    
    Ok(exp_x / sum)
}
```

---

## ã¾ã¨ã‚

| å´é¢ | Python (PyTorch) | Rust |
|------|-----------------|------|
| **ãƒ‡ãƒãƒƒã‚°å®¹æ˜“æ€§** | é«˜ï¼ˆå‹•çš„å‹ä»˜ã‘ï¼‰ | ä¸­ï¼ˆã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚¨ãƒ©ãƒ¼è±Šå¯Œï¼‰ |
| **ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒªãƒ³ã‚°** | torch.profiler | Nsight, perf, flamegraph |
| **ãƒ¡ãƒ¢ãƒªå®‰å…¨æ€§** | GCã«ä¾å­˜ | ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ä¿è¨¼ |
| **ãƒ†ã‚¹ãƒˆãƒ„ãƒ¼ãƒ«** | pytest, unittest | cargo test, proptest |
| **CI/CDçµ±åˆ** | å®¹æ˜“ | å®¹æ˜“ï¼ˆGitHub Actionsï¼‰ |

**Rust ã®åˆ©ç‚¹**:
- ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã®å‹å®‰å…¨æ€§ãƒ»ãƒ¡ãƒ¢ãƒªå®‰å…¨æ€§
- Miri ã«ã‚ˆã‚‹UBæ¤œå‡º
- TSan ã«ã‚ˆã‚‹ãƒ‡ãƒ¼ã‚¿ç«¶åˆæ¤œå‡º

**Python ã®åˆ©ç‚¹**:
- ãƒ‡ãƒãƒƒã‚°ã®å®¹æ˜“æ€§
- ã‚¨ã‚³ã‚·ã‚¹ãƒ†ãƒ ã®å……å®Ÿ

---

## å‚è€ƒæ–‡çŒ®

1. NVIDIA Nsight Systems User Guide. https://docs.nvidia.com/nsight-systems/
2. NVIDIA Nsight Compute. https://developer.nvidia.com/nsight-compute
3. Valgrind User Manual. https://valgrind.org/docs/manual/
4. Gregg, B. "Flame Graphs." Communications of the ACM, 2016.
5. Serebryany, K., et al. (2012). "AddressSanitizer: A Fast Address Sanity Checker." USENIX ATC.
6. Rust Miri Documentation. https://github.com/rust-lang/miri
7. proptest Book. https://altsysrq.github.io/proptest-book/
8. Criterion.rs User Guide. https://bheisler.github.io/criterion.rs/book/
9. Peterson, J. "Continuous Integration for Rust Projects." Rust Blog, 2021.
10. Klabnik, S., & Nichols, C. (2019). "The Rust Programming Language." No Starch Press. (Chapter 11: Testing)
---

[ğŸ“š ç›®æ¬¡ã«æˆ»ã‚‹](../README.md) | [â¬…ï¸ ç¬¬13ç« : å­¦ç¿’ãƒ«ãƒ¼ãƒ—ã¨æœ€é©åŒ–æ‰‹æ³•](04-13-å­¦ç¿’ãƒ«ãƒ¼ãƒ—ã¨æœ€é©åŒ–æ‰‹æ³•.md) | [â¡ï¸ ç¬¬15ç« : ãƒ¢ãƒ‡ãƒ«æ¨è«–ã¨ONNXäº’æ›](../05_ç¬¬Véƒ¨_å¿œç”¨ã¨é«˜åº¦åŒ–/05-15-ãƒ¢ãƒ‡ãƒ«æ¨è«–ã¨ONNXäº’æ›.md)