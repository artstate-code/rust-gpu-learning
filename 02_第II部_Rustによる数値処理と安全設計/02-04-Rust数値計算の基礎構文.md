[ğŸ“š ç›®æ¬¡](../README.md) | [â¬…ï¸ ç¬¬3ç« ](../01_ç¬¬Iéƒ¨_åŸºç¤ç†è«–ã¨å…¨ä½“åƒ/01-03-è‡ªå‹•å¾®åˆ†ã®ä»•çµ„ã¿.md) | [â¡ï¸ ç¬¬5ç« ](02-05-ä¸¦åˆ—è¨ˆç®—ã¨éåŒæœŸå‡¦ç†.md)

---

# ç¬¬ 4 ç« ã€€Rustæ•°å€¤è¨ˆç®—ã®åŸºç¤æ§‹æ–‡

ã“ã®ç« ã§ã¯ã€Rustã®å‹ã‚·ã‚¹ãƒ†ãƒ ã€æ‰€æœ‰æ¨©ã€ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ã¨ã„ã£ãŸç‹¬è‡ªã®æ¦‚å¿µã‚’ç†è§£ã—ã€æ•°å€¤è¨ˆç®—ãƒ©ã‚¤ãƒ–ãƒ©ãƒªï¼ˆndarray, nalgebraï¼‰ã®ä½¿ã„æ–¹ã‚’å­¦ã³ã¾ã™ã€‚Pythonï¼ˆNumPyï¼‰ã‹ã‚‰ã®ç§»è¡Œã‚’æƒ³å®šã—ã€æ¯”è¼ƒã—ãªãŒã‚‰è§£èª¬ã—ã¾ã™ã€‚

**ç›®çš„**: Rustã®å®‰å…¨æ€§æ©Ÿèƒ½ã‚’æ´»ã‹ã—ã¤ã¤ã€é«˜æ€§èƒ½ãªæ•°å€¤è¨ˆç®—ã‚³ãƒ¼ãƒ‰ã‚’æ›¸ããŸã‚ã®åŸºç¤ã‚’ç¿’å¾—ã—ã¾ã™ã€‚

## 4.1 æ‰€æœ‰æ¨©ãƒ»å€Ÿç”¨ãƒ»ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ 

Rustã®æœ€ã‚‚ç‰¹å¾´çš„ãªæ©Ÿèƒ½ã§ã‚ã‚‹**æ‰€æœ‰æ¨©ã‚·ã‚¹ãƒ†ãƒ **ã¯ã€ã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ç„¡ã—ã§ãƒ¡ãƒ¢ãƒªå®‰å…¨æ€§ã‚’ä¿è¨¼ã—ã¾ã™ [^1]ã€‚æ•°å€¤è¨ˆç®—ã§ã¯å¤§é‡ã®ãƒ¡ãƒ¢ãƒªã‚’æ‰±ã†ãŸã‚ã€ã“ã®ç†è§£ãŒä¸å¯æ¬ ã§ã™ã€‚

[^1]: The Rust Book, Chapter 4: Understanding Ownership, https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html

### æ‰€æœ‰æ¨©ã®åŸºæœ¬ãƒ«ãƒ¼ãƒ«

Rustã§ã¯ã€ä»¥ä¸‹ã®3ã¤ã®ãƒ«ãƒ¼ãƒ«ãŒå¸¸ã«é©ç”¨ã•ã‚Œã¾ã™ï¼š

1. **å„å€¤ã¯ã€ãã‚Œã‚’æ‰€æœ‰ã™ã‚‹å¤‰æ•°ï¼ˆæ‰€æœ‰è€…ï¼‰ã‚’æŒã¤**
2. **æ‰€æœ‰è€…ã¯åŒæ™‚ã«1ã¤ã ã‘**
3. **æ‰€æœ‰è€…ãŒã‚¹ã‚³ãƒ¼ãƒ—ã‚’æŠœã‘ã‚‹ã¨ã€å€¤ã¯ç ´æ£„ã•ã‚Œã‚‹**

#### Python ã¨ã®æ¯”è¼ƒ

| æ¦‚å¿µ | Python | Rust |
|------|--------|------|
| ãƒ¡ãƒ¢ãƒªç®¡ç† | ã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ | æ‰€æœ‰æ¨©ã‚·ã‚¹ãƒ†ãƒ  |
| å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆ | è‡ªå‹•ï¼ˆå†…éƒ¨å®Ÿè£…ï¼‰ | æ˜ç¤ºçš„ï¼ˆ`Rc`, `Arc`ï¼‰ |
| ã‚³ãƒ”ãƒ¼ | æš—é»™çš„ï¼ˆå¯å¤‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯å‚ç…§ï¼‰ | æ˜ç¤ºçš„ï¼ˆ`Copy` or `Clone`ï¼‰ |
| ãƒ¡ãƒ¢ãƒªè§£æ”¾ | GC ãŒæ±ºå®š | ã‚¹ã‚³ãƒ¼ãƒ—çµ‚äº†æ™‚ã«æ±ºå®šçš„ |
| ä¸¦è¡Œæ€§ | GIL ã«ã‚ˆã‚Šåˆ¶é™ | ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã«å®‰å…¨æ€§ä¿è¨¼ |

#### å®Ÿä¾‹ï¼šé…åˆ—ã®æ‰€æœ‰æ¨©ç§»å‹•

```rust
fn main() {
    let v1 = vec![1.0, 2.0, 3.0, 4.0];
    let v2 = v1;  // æ‰€æœ‰æ¨©ãŒ v1 ã‹ã‚‰ v2 ã¸ç§»å‹•ï¼ˆãƒ ãƒ¼ãƒ–ï¼‰
    
    // println!("{:?}", v1);  // ã‚¨ãƒ©ãƒ¼ï¼v1 ã¯æ—¢ã«ç„¡åŠ¹
    println!("{:?}", v2);  // OK
}
```

```python
# Python: å‚ç…§ã®ã‚³ãƒ”ãƒ¼
v1 = [1.0, 2.0, 3.0, 4.0]
v2 = v1  # å‚ç…§ã®ã‚³ãƒ”ãƒ¼ï¼ˆä¸¡æ–¹ã¨ã‚‚åŒã˜ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æŒ‡ã™ï¼‰

v1.append(5.0)
print(v2)  # [1.0, 2.0, 3.0, 4.0, 5.0] - v1ã®å¤‰æ›´ãŒv2ã«ã‚‚åæ˜ 
```

### å€Ÿç”¨ï¼ˆBorrowingï¼‰

**å€Ÿç”¨**ã¯ã€æ‰€æœ‰æ¨©ã‚’ç§»å‹•ã›ãšã«å€¤ã‚’å‚ç…§ã™ã‚‹ä»•çµ„ã¿ã§ã™ã€‚

#### ä¸å¤‰å€Ÿç”¨ï¼ˆImmutable Borrowï¼‰

```rust
fn sum(v: &Vec<f64>) -> f64 {
    v.iter().sum()
}

fn main() {
    let data = vec![1.0, 2.0, 3.0];
    let s = sum(&data);  // data ã‚’å€Ÿç”¨
    println!("Sum: {}, Data: {:?}", s, data);  // data ã¯ã¾ã æœ‰åŠ¹
}
```

#### å¯å¤‰å€Ÿç”¨ï¼ˆMutable Borrowï¼‰

```rust
fn scale(v: &mut Vec<f64>, factor: f64) {
    for x in v.iter_mut() {
        *x *= factor;
    }
}

fn main() {
    let mut data = vec![1.0, 2.0, 3.0];
    scale(&mut data, 2.0);
    println!("{:?}", data);  // [2.0, 4.0, 6.0]
}
```

#### å€Ÿç”¨ãƒ«ãƒ¼ãƒ«

| ãƒ«ãƒ¼ãƒ« | èª¬æ˜ |
|--------|------|
| **ãƒ«ãƒ¼ãƒ«1** | ä¸å¤‰å€Ÿç”¨ã¯è¤‡æ•°åŒæ™‚ã«å¯èƒ½ |
| **ãƒ«ãƒ¼ãƒ«2** | å¯å¤‰å€Ÿç”¨ã¯åŒæ™‚ã«1ã¤ã ã‘ |
| **ãƒ«ãƒ¼ãƒ«3** | ä¸å¤‰å€Ÿç”¨ã¨å¯å¤‰å€Ÿç”¨ã¯åŒæ™‚ã«ä¸å¯ |

ã“ã‚Œã‚‰ã®ãƒ«ãƒ¼ãƒ«ã«ã‚ˆã‚Šã€**ãƒ‡ãƒ¼ã‚¿ç«¶åˆãŒã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã«é˜²æ­¢**ã•ã‚Œã¾ã™ã€‚

### ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ 

**ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ **ã¯ã€å‚ç…§ãŒæœ‰åŠ¹ãªæœŸé–“ã‚’è¡¨ã™æ¦‚å¿µã§ã™ã€‚

```rust
// ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ æ³¨é‡ˆãŒå¿…è¦ãªä¾‹
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() { x } else { y }
}

fn main() {
    let s1 = String::from("long string");
    let s2 = String::from("short");
    let result = longest(&s1, &s2);
    println!("{}", result);
}
```

**ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ æ³¨é‡ˆ** `'a` ã¯ã€ã€Œè¿”ã‚Šå€¤ã®å‚ç…§ã¯ã€x ã¨ y ã®ä¸¡æ–¹ãŒæœ‰åŠ¹ãªé–“ã ã‘æœ‰åŠ¹ã€ã¨ã„ã†åˆ¶ç´„ã‚’è¡¨ã—ã¾ã™ã€‚

#### æ•°å€¤è¨ˆç®—ã§ã®å®Ÿè·µä¾‹

```rust
use ndarray::Array1;

// ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ã‚’æ˜ç¤ºã—ãŸé–¢æ•°
fn dot_product<'a>(a: &'a Array1<f64>, b: &'a Array1<f64>) -> f64 {
    assert_eq!(a.len(), b.len(), "Vectors must have same length");
    a.iter().zip(b.iter()).map(|(x, y)| x * y).sum()
}

fn main() {
    let v1 = Array1::from_vec(vec![1.0, 2.0, 3.0]);
    let v2 = Array1::from_vec(vec![4.0, 5.0, 6.0]);
    
    let result = dot_product(&v1, &v2);
    println!("Dot product: {}", result);  // 32.0
}
```

### ãƒ¡ãƒ¢ãƒªãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã¨æ€§èƒ½

Rustã®æ‰€æœ‰æ¨©ã‚·ã‚¹ãƒ†ãƒ ã¯ã€ãƒ¡ãƒ¢ãƒªãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã‚’æ˜ç¢ºã«ã—ã¾ã™ï¼š

| ãƒ‡ãƒ¼ã‚¿æ§‹é€  | ãƒ’ãƒ¼ãƒ—å‰²ã‚Šå½“ã¦ | ã‚¹ã‚¿ãƒƒã‚¯ | ã‚³ãƒ”ãƒ¼ã‚³ã‚¹ãƒˆ |
|-----------|-------------|---------|------------|
| `Vec<f64>` | â—‹ï¼ˆãƒ‡ãƒ¼ã‚¿æœ¬ä½“ï¼‰ | ãƒã‚¤ãƒ³ã‚¿+é•·ã•+å®¹é‡ | O(1)ï¼ˆãƒã‚¤ãƒ³ã‚¿ã®ã¿ï¼‰ |
| `Array1<f64>` | â—‹ï¼ˆãƒ‡ãƒ¼ã‚¿æœ¬ä½“ï¼‰ | ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ | O(1)ï¼ˆå‚ç…§ã‚«ã‚¦ãƒ³ãƒˆï¼‰ |
| `[f64; 4]` | âœ— | å…¨ãƒ‡ãƒ¼ã‚¿ | O(n)ï¼ˆå…¨è¦ç´ ï¼‰ |

**æ€§èƒ½ã¸ã®å½±éŸ¿**:

```rust
// âŒ éåŠ¹ç‡ï¼šæ¯å›ã‚³ãƒ”ãƒ¼ãŒç™ºç”Ÿ
fn process_bad(data: Vec<f64>) -> Vec<f64> {
    data.iter().map(|x| x * 2.0).collect()
}

// âœ… åŠ¹ç‡çš„ï¼šå€Ÿç”¨ã‚’ä½¿ç”¨
fn process_good(data: &[f64]) -> Vec<f64> {
    data.iter().map(|x| x * 2.0).collect()
}

// âœ… æœ€ã‚‚åŠ¹ç‡çš„ï¼šin-place å¤‰æ›´
fn process_best(data: &mut [f64]) {
    for x in data {
        *x *= 2.0;
    }
}
```

## 4.2 ndarray ã¨ nalgebra ã«ã‚ˆã‚‹ãƒ†ãƒ³ã‚½ãƒ«æ¼”ç®—

Rustã§NumPyé¢¨ã®é…åˆ—æ“ä½œã‚’è¡Œã†ã«ã¯ã€**ndarray**ã‚¯ãƒ¬ãƒ¼ãƒˆã‚’ä½¿ç”¨ã—ã¾ã™ [^2]ã€‚ç·šå½¢ä»£æ•°ã«ç‰¹åŒ–ã—ãŸæ¼”ç®—ã«ã¯**nalgebra**ã‚‚æœ‰ç”¨ã§ã™ [^3]ã€‚

[^2]: ndarray: https://docs.rs/ndarray/
[^3]: nalgebra: https://docs.rs/nalgebra/

### ndarray ã®åŸºæœ¬

#### é…åˆ—ã®ä½œæˆ

```rust
use ndarray::{array, Array1, Array2, Array3};

fn main() {
    // 1æ¬¡å…ƒé…åˆ—
    let a = array![1.0, 2.0, 3.0];
    
    // 2æ¬¡å…ƒé…åˆ—ï¼ˆè¡Œåˆ—ï¼‰
    let b = array![[1.0, 2.0], [3.0, 4.0]];
    
    // ã‚¼ãƒ­åˆæœŸåŒ–
    let zeros = Array2::<f64>::zeros((3, 4));
    
    // å˜ä½è¡Œåˆ—
    let identity = Array2::<f64>::eye(3);
    
    // ç¯„å›²ã‹ã‚‰ç”Ÿæˆ
    let range = Array1::range(0.0, 10.0, 1.0);
    
    // ãƒ©ãƒ³ãƒ€ãƒ ï¼ˆè¦rand_distrã‚¯ãƒ¬ãƒ¼ãƒˆï¼‰
    use ndarray_rand::RandomExt;
    use ndarray_rand::rand_distr::Uniform;
    let random = Array2::random((3, 3), Uniform::new(0.0, 1.0));
}
```

#### Pythonï¼ˆNumPyï¼‰ã¨ã®æ¯”è¼ƒ

| æ“ä½œ | NumPy | ndarray |
|------|-------|---------|
| 1Dé…åˆ— | `np.array([1, 2, 3])` | `array![1, 2, 3]` |
| 2Dé…åˆ— | `np.array([[1, 2], [3, 4]])` | `array![[1, 2], [3, 4]]` |
| ã‚¼ãƒ­ | `np.zeros((3, 4))` | `Array2::zeros((3, 4))` |
| å˜ä½è¡Œåˆ— | `np.eye(3)` | `Array2::eye(3)` |
| ç¯„å›² | `np.arange(0, 10, 1)` | `Array1::range(0.0, 10.0, 1.0)` |
| ãƒ©ãƒ³ãƒ€ãƒ  | `np.random.rand(3, 3)` | `Array2::random((3, 3), ...)` |

#### åŸºæœ¬æ¼”ç®—

```rust
use ndarray::prelude::*;

fn main() {
    let a = array![[1.0, 2.0], [3.0, 4.0]];
    let b = array![[5.0, 6.0], [7.0, 8.0]];
    
    // è¦ç´ ã”ã¨ã®æ¼”ç®—
    let sum = &a + &b;
    let product = &a * &b;
    
    // ã‚¹ã‚«ãƒ©ãƒ¼æ¼”ç®—
    let scaled = &a * 2.0;
    
    // è¡Œåˆ—ç©
    let matmul = a.dot(&b);
    
    // è»¢ç½®
    let transposed = a.t();
    
    // é›†ç´„æ¼”ç®—
    let total: f64 = a.sum();
    let mean: f64 = a.mean().unwrap();
    let max: f64 = a.iter().cloned().fold(f64::NEG_INFINITY, f64::max);
}
```

### Broadcastingï¼ˆãƒ–ãƒ­ãƒ¼ãƒ‰ã‚­ãƒ£ã‚¹ãƒˆï¼‰

NumPyã¨åŒæ§˜ã€ndarrayã‚‚ãƒ–ãƒ­ãƒ¼ãƒ‰ã‚­ãƒ£ã‚¹ãƒˆã‚’ã‚µãƒãƒ¼ãƒˆã—ã¾ã™ [^4]ï¼š

[^4]: Broadcasting rules: https://numpy.org/doc/stable/user/basics.broadcasting.html

```rust
use ndarray::prelude::*;

fn main() {
    let matrix = array![[1.0, 2.0, 3.0],
                        [4.0, 5.0, 6.0]];
    let row = array![10.0, 20.0, 30.0];
    
    // (2, 3) + (3,) -> (2, 3)
    let result = &matrix + &row;
    println!("{:?}", result);
    // [[11.0, 22.0, 33.0],
    //  [14.0, 25.0, 36.0]]
}
```

**ãƒ–ãƒ­ãƒ¼ãƒ‰ã‚­ãƒ£ã‚¹ãƒˆè¦å‰‡**:

1. æ¬¡å…ƒæ•°ãŒç•°ãªã‚‹å ´åˆã€å°ã•ã„æ–¹ã®å…ˆé ­ã«1ã‚’è¿½åŠ 
2. å„è»¸ã§ã€ã‚µã‚¤ã‚ºãŒ1 or ä¸€è‡´ã™ã‚‹å¿…è¦ãŒã‚ã‚‹
3. ã‚µã‚¤ã‚º1ã®è»¸ã¯ã€ã‚‚ã†ä¸€æ–¹ã®ã‚µã‚¤ã‚ºã«æ‹¡å¼µã•ã‚Œã‚‹

### Slicing ã¨ View

```rust
use ndarray::prelude::*;

fn main() {
    let mut a = Array2::from_shape_fn((4, 5), |(i, j)| (i * 5 + j) as f64);
    
    // ã‚¹ãƒ©ã‚¤ã‚¹ï¼ˆãƒ“ãƒ¥ãƒ¼ã€ã‚³ãƒ”ãƒ¼ãªã—ï¼‰
    let slice = a.slice(s![1..3, 2..4]);
    println!("{:?}", slice);
    
    // å¯å¤‰ã‚¹ãƒ©ã‚¤ã‚¹
    let mut slice_mut = a.slice_mut(s![.., 0]);
    slice_mut.fill(0.0);
    
    // è¡Œ/åˆ—ã®æŠ½å‡º
    let row = a.row(0);
    let col = a.column(2);
}
```

**ãƒ¡ãƒ¢ãƒªåŠ¹ç‡**:

| æ“ä½œ | ã‚³ãƒ”ãƒ¼ | è¨ˆç®—é‡ |
|------|-------|--------|
| `slice` | âœ—ï¼ˆãƒ“ãƒ¥ãƒ¼ï¼‰ | O(1) |
| `to_owned` | â—‹ | O(n) |
| `mapv` | â—‹ï¼ˆæ–°é…åˆ—ï¼‰ | O(n) |
| `mapv_inplace` | âœ—ï¼ˆin-placeï¼‰ | O(n) |

### nalgebra ã¨ã®ä½¿ã„åˆ†ã‘

| ç‰¹å¾´ | ndarray | nalgebra |
|------|---------|----------|
| ä¸»ãªç”¨é€” | NumPyé¢¨ã®é…åˆ—æ“ä½œ | ç·šå½¢ä»£æ•°ãƒ»å¹¾ä½•å­¦ |
| æ¬¡å…ƒ | å‹•çš„ï¼ˆä»»æ„æ¬¡å…ƒï¼‰ | ä¸»ã«é™çš„ï¼ˆã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ç¢ºå®šï¼‰ |
| æ€§èƒ½ | å¤§è¦æ¨¡é…åˆ—ã«æœ€é©åŒ– | å°è¦æ¨¡è¡Œåˆ—ï¼ˆâ‰¤16x16ï¼‰ã«æœ€é© |
| ãƒ¡ãƒ¢ãƒªãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ | è¡Œå„ªå…ˆ/åˆ—å„ªå…ˆ é¸æŠå¯ | åˆ—å„ªå…ˆ |
| GPUå¯¾å¿œ | å¤–éƒ¨ã‚¯ãƒ¬ãƒ¼ãƒˆå¿…è¦ | é™å®šçš„ |

#### nalgebra ã®ä¾‹

```rust
use nalgebra as na;

fn main() {
    // é™çš„ã‚µã‚¤ã‚ºã®è¡Œåˆ—ï¼ˆã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã«ã‚µã‚¤ã‚ºç¢ºå®šï¼‰
    let m = na::Matrix3::new(
        1.0, 2.0, 3.0,
        4.0, 5.0, 6.0,
        7.0, 8.0, 9.0
    );
    
    // å‹•çš„ã‚µã‚¤ã‚ºã®è¡Œåˆ—
    let dyn_m = na::DMatrix::from_row_slice(3, 3, &[
        1.0, 2.0, 3.0,
        4.0, 5.0, 6.0,
        7.0, 8.0, 9.0
    ]);
    
    // LUåˆ†è§£
    let lu = m.lu();
    
    // å›ºæœ‰å€¤
    let eigen = m.symmetric_eigen();
    
    // QRåˆ†è§£
    let qr = m.qr();
}
```

### BLAS ã¨ã®é€£æº

é«˜æ€§èƒ½ãªè¡Œåˆ—æ¼”ç®—ã«ã¯ã€**BLAS**ï¼ˆBasic Linear Algebra Subprogramsï¼‰ã‚’ä½¿ç”¨ã—ã¾ã™ [^5]ï¼š

[^5]: BLAS ã¯ã€ç·šå½¢ä»£æ•°æ¼”ç®—ã®æ¨™æº–APIã§ã€Intel MKLã€OpenBLASã€Apple Accelerateãªã©ã®å®Ÿè£…ãŒã‚ã‚Šã¾ã™

```toml
# Cargo.toml
[dependencies]
ndarray = { version = "0.15", features = ["blas"] }
blas-src = { version = "0.10", features = ["openblas"] }
openblas-src = { version = "0.10", features = ["cblas", "system"] }
```

```rust
use ndarray::prelude::*;
use ndarray_linalg::*;

fn main() {
    let a = Array2::random((1000, 1000), ndarray_rand::rand_distr::Uniform::new(0.0, 1.0));
    let b = Array2::random((1000, 1000), ndarray_rand::rand_distr::Uniform::new(0.0, 1.0));
    
    // BLAS ã‚’ä½¿ã£ãŸé«˜é€Ÿãªè¡Œåˆ—ç©
    let c = a.dot(&b);
    
    // SVDï¼ˆç‰¹ç•°å€¤åˆ†è§£ï¼‰
    let (u, s, vt) = a.svd(true, true).unwrap();
}
```

**æ€§èƒ½æ¯”è¼ƒ**ï¼ˆ1000x1000è¡Œåˆ—ç©ï¼‰:

| å®Ÿè£… | æ™‚é–“ | GFLOPS |
|------|------|--------|
| ç´ æœ´ãªå®Ÿè£… | ~8000 ms | ~0.25 |
| ndarray | ~800 ms | ~2.5 |
| ndarray + OpenBLAS | ~15 ms | ~133 |
| cuBLAS (GPU) | ~1 ms | ~2000 |

## 4.3 unsafe ãƒ–ãƒ­ãƒƒã‚¯ã‚’å±€æ‰€åŒ–ã™ã‚‹è¨­è¨ˆ

Rustã®**unsafe**ã¯ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã®ãƒ¡ãƒ¢ãƒªå®‰å…¨æ€§ãƒã‚§ãƒƒã‚¯ã‚’å›é¿ã™ã‚‹æ©Ÿèƒ½ã§ã™ã€‚GPUè¨ˆç®—ã‚„FFIã§ã¯é¿ã‘ã‚‰ã‚Œã¾ã›ã‚“ãŒã€**å½±éŸ¿ç¯„å›²ã‚’æœ€å°åŒ–**ã™ã‚‹ã“ã¨ãŒé‡è¦ã§ã™ã€‚

### unsafe ãŒå¿…è¦ãª5ã¤ã®ã‚±ãƒ¼ã‚¹

1. **ç”Ÿãƒã‚¤ãƒ³ã‚¿ã®å‚ç…§å¤–ã—**
2. **unsafe ãªé–¢æ•°/ãƒ¡ã‚½ãƒƒãƒ‰ã®å‘¼ã³å‡ºã—**
3. **å¯å¤‰ãªé™çš„å¤‰æ•°ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹**
4. **unsafe ãƒˆãƒ¬ã‚¤ãƒˆã®å®Ÿè£…**
5. **union ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹**

### å®‰å…¨ãªæŠ½è±¡åŒ–ãƒ‘ã‚¿ãƒ¼ãƒ³

**unsafeå¢ƒç•Œã®è¨­è¨ˆ**:

```mermaid
graph TD
    subgraph Safe[å®‰å…¨ãªé ˜åŸŸ Safe Rust]
        User[ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚³ãƒ¼ãƒ‰] --> API[å…¬é–‹API<br/>å®‰å…¨ãªå‹]
    end
    
    subgraph Wrapper[ãƒ©ãƒƒãƒ‘ãƒ¼å±¤]
        API --> Validation[å…¥åŠ›æ¤œè¨¼<br/>å¢ƒç•Œãƒã‚§ãƒƒã‚¯]
        Validation --> Unsafe[unsafe ãƒ–ãƒ­ãƒƒã‚¯<br/>æœ€å°ç¯„å›²]
    end
    
    subgraph FFI[FFIå±¤]
        Unsafe --> C_API[C/CUDA API<br/>ç”Ÿãƒã‚¤ãƒ³ã‚¿]
    end
    
    style User fill:#e1ffe1
    style API fill:#e1ffe1
    style Validation fill:#fff4e1
    style Unsafe fill:#ffe1e1
    style C_API fill:#ff9999
```

#### ãƒ‘ã‚¿ãƒ¼ãƒ³1: Safe Wrapper

```rust
// âŒ æ‚ªã„ä¾‹ï¼šunsafe ãŒåºƒç¯„å›²ã«éœ²å‡º
pub fn matrix_multiply(a: *const f32, b: *const f32, c: *mut f32, n: usize) {
    unsafe {
        // ... ç”Ÿãƒã‚¤ãƒ³ã‚¿æ“ä½œ ...
    }
}

// âœ… è‰¯ã„ä¾‹ï¼šå®‰å…¨ãªã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹
pub fn matrix_multiply(a: &[f32], b: &[f32]) -> Vec<f32> {
    assert_eq!(a.len(), b.len());
    let n = (a.len() as f64).sqrt() as usize;
    let mut c = vec![0.0; n * n];
    
    unsafe {
        // unsafe ã¯ã“ã®ä¸­ã ã‘ã«å±€æ‰€åŒ–
        raw_matrix_multiply(
            a.as_ptr(), b.as_ptr(), c.as_mut_ptr(), n
        );
    }
    
    c
}

unsafe fn raw_matrix_multiply(
    a: *const f32, b: *const f32, c: *mut f32, n: usize
) {
    // ä½ãƒ¬ãƒ™ãƒ«å®Ÿè£…
}
```

#### ãƒ‘ã‚¿ãƒ¼ãƒ³2: Type-safe Abstraction

```rust
use std::marker::PhantomData;

// å‹å®‰å…¨ãªGPUãƒãƒƒãƒ•ã‚¡
pub struct GpuBuffer<T> {
    ptr: *mut T,
    len: usize,
    _marker: PhantomData<T>,
}

impl<T> GpuBuffer<T> {
    // å®‰å…¨ãªã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
    pub fn new(len: usize) -> Self {
        let ptr = unsafe {
            // unsafe ã¯ã“ã®ä¸­ã ã‘
            cuda_malloc(len * std::mem::size_of::<T>())
        };
        
        Self {
            ptr,
            len,
            _marker: PhantomData,
        }
    }
    
    // å®‰å…¨ãªã‚¢ã‚¯ã‚»ã‚¹
    pub fn copy_from_slice(&mut self, src: &[T]) {
        assert_eq!(self.len, src.len());
        unsafe {
            cuda_memcpy(
                self.ptr as *mut _,
                src.as_ptr() as *const _,
                self.len * std::mem::size_of::<T>()
            );
        }
    }
    
    pub fn len(&self) -> usize {
        self.len
    }
}

impl<T> Drop for GpuBuffer<T> {
    fn drop(&mut self) {
        unsafe {
            cuda_free(self.ptr as *mut _);
        }
    }
}

// unsafe ãªå¤–éƒ¨é–¢æ•°ï¼ˆå®Ÿéš›ã¯CUDAã®FFIï¼‰
unsafe fn cuda_malloc(size: usize) -> *mut u8 { todo!() }
unsafe fn cuda_memcpy(dst: *mut u8, src: *const u8, size: usize) { todo!() }
unsafe fn cuda_free(ptr: *mut u8) { todo!() }
```

### Invariantï¼ˆä¸å¤‰æ¡ä»¶ï¼‰ã®æ–‡æ›¸åŒ–

```rust
/// GPUãƒ¡ãƒ¢ãƒªã¸ã®å®‰å…¨ãªã‚¢ã‚¯ã‚»ã‚¹ã‚’æä¾›
/// 
/// # Safety Invariants
/// - `ptr` ã¯æœ‰åŠ¹ãªGPUãƒ¡ãƒ¢ãƒªã‚’æŒ‡ã™
/// - `len` ã¯ãƒã‚¤ãƒˆæ•°ã§ã¯ãªãè¦ç´ æ•°
/// - Dropæ™‚ã«GPUãƒ¡ãƒ¢ãƒªã¯å¿…ãšè§£æ”¾ã•ã‚Œã‚‹
pub struct GpuArray<T> {
    ptr: *mut T,
    len: usize,
    _marker: PhantomData<T>,
}

impl<T> GpuArray<T> {
    /// æ–°ã—ã„GPUé…åˆ—ã‚’ä½œæˆ
    /// 
    /// # Safety
    /// ã“ã®é–¢æ•°ã¯å†…éƒ¨ã§ `cuda_malloc` ã‚’å‘¼ã¶ãŒã€
    /// å‘¼ã³å‡ºã—å…ƒã«ã¯ unsafe ã‚’è¦æ±‚ã—ãªã„ã€‚
    /// ã‚¨ãƒ©ãƒ¼æ™‚ã¯ panic ã™ã‚‹ã€‚
    pub fn new(len: usize) -> Self {
        // ...
    }
}
```

### ãƒ‡ãƒãƒƒã‚°ã¨ãƒ†ã‚¹ãƒˆ

```rust
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_gpu_buffer_safety() {
        let mut buffer = GpuBuffer::<f32>::new(100);
        let data: Vec<f32> = (0..100).map(|i| i as f32).collect();
        
        // å¢ƒç•Œãƒã‚§ãƒƒã‚¯ãŒã•ã‚Œã‚‹ã“ã¨ã‚’ç¢ºèª
        buffer.copy_from_slice(&data);
        
        // ãƒ‘ãƒ‹ãƒƒã‚¯ã™ã‚‹ã“ã¨ã‚’ç¢ºèª
        let result = std::panic::catch_unwind(|| {
            let wrong_size = vec![0.0; 50];
            buffer.copy_from_slice(&wrong_size);
        });
        assert!(result.is_err());
    }
}
```

## 4.4 FFI ã¨ `#[repr(C)]` ã®æ•´åˆæ€§ç¢ºèª

**FFI**ï¼ˆForeign Function Interfaceï¼‰ã¯ã€Rustã‹ã‚‰ä»–è¨€èªï¼ˆä¸»ã«C/C++ï¼‰ã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’å‘¼ã³å‡ºã™ä»•çµ„ã¿ã§ã™ã€‚GPUè¨ˆç®—ã§ã¯ã€CUDA/cuBLAS/cuDNNãªã©ã®C APIã¨é€£æºã—ã¾ã™ã€‚

### `#[repr(C)]` ã®å¿…è¦æ€§

Rustã®æ§‹é€ ä½“ã¯ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ãƒ¡ãƒ¢ãƒªãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆãŒ**æœªå®šç¾©**ã§ã™ã€‚Cè¨€èªã¨äº’æ›æ€§ã‚’æŒãŸã›ã‚‹ã«ã¯ã€`#[repr(C)]` å±æ€§ãŒå¿…é ˆã§ã™ã€‚

```rust
// âŒ C ã¨äº’æ›æ€§ãªã—
struct Matrix {
    rows: usize,
    cols: usize,
    data: Vec<f32>,
}

// âœ… C ã¨äº’æ›æ€§ã‚ã‚Š
#[repr(C)]
struct CMatrix {
    rows: usize,
    cols: usize,
    data: *mut f32,
}
```

**ãƒ¡ãƒ¢ãƒªãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã®æ¯”è¼ƒ**:

| å‹ | Rustãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ | `#[repr(C)]` | ã‚µã‚¤ã‚ºï¼ˆ64-bitï¼‰ |
|-----|--------------|-------------|----------------|
| `struct { u8, u32 }` | æœ€é©åŒ–ï¼ˆãƒ‘ãƒ‡ã‚£ãƒ³ã‚°ä¸å®šï¼‰ | Cäº’æ›ï¼ˆãƒ‘ãƒ‡ã‚£ãƒ³ã‚°è¿½åŠ ï¼‰ | 8 bytes |
| `enum` | ã‚¿ã‚° + ãƒ‡ãƒ¼ã‚¿ï¼ˆæœ€é©åŒ–ï¼‰ | Cäº’æ›ï¼ˆæ˜ç¤ºçš„ã‚¿ã‚°ï¼‰ | 16 bytes |
| `Option<Box<T>>` | null pointeræœ€é©åŒ– | ä½¿ç”¨ä¸å¯ | - |

### CUDA FFI ã®ä¾‹

```rust
// CUDA ã®å¤–éƒ¨é–¢æ•°ã‚’å®£è¨€
extern "C" {
    fn cudaMalloc(ptr: *mut *mut std::ffi::c_void, size: usize) -> i32;
    fn cudaMemcpy(
        dst: *mut std::ffi::c_void,
        src: *const std::ffi::c_void,
        count: usize,
        kind: i32,
    ) -> i32;
    fn cudaFree(ptr: *mut std::ffi::c_void) -> i32;
}

// Cäº’æ›ã®ã‚¨ãƒ©ãƒ¼ã‚³ãƒ¼ãƒ‰
const CUDA_SUCCESS: i32 = 0;
const CUDA_MEMCPY_HOST_TO_DEVICE: i32 = 1;

// å®‰å…¨ãªãƒ©ãƒƒãƒ‘ãƒ¼
pub fn cuda_alloc<T>(count: usize) -> Result<*mut T, String> {
    let mut ptr: *mut std::ffi::c_void = std::ptr::null_mut();
    let size = count * std::mem::size_of::<T>();
    
    let result = unsafe {
        cudaMalloc(&mut ptr as *mut _, size)
    };
    
    if result == CUDA_SUCCESS {
        Ok(ptr as *mut T)
    } else {
        Err(format!("cudaMalloc failed with code {}", result))
    }
}
```

### cuBLAS ã¨ã®é€£æº

```rust
// cuBLAS ã®FFIå®šç¾©
#[repr(C)]
struct cublasHandle {
    _private: [u8; 0],
}

type cublasHandle_t = *mut cublasHandle;

#[repr(i32)]
enum cublasOperation {
    CUBLAS_OP_N = 0,
    CUBLAS_OP_T = 1,
}

extern "C" {
    fn cublasCreate_v2(handle: *mut cublasHandle_t) -> i32;
    fn cublasDestroy_v2(handle: cublasHandle_t) -> i32;
    fn cublasSgemm_v2(
        handle: cublasHandle_t,
        transa: i32,
        transb: i32,
        m: i32,
        n: i32,
        k: i32,
        alpha: *const f32,
        A: *const f32,
        lda: i32,
        B: *const f32,
        ldb: i32,
        beta: *const f32,
        C: *mut f32,
        ldc: i32,
    ) -> i32;
}

// Rustãƒ©ãƒƒãƒ‘ãƒ¼
pub struct CublasHandle {
    handle: cublasHandle_t,
}

impl CublasHandle {
    pub fn new() -> Result<Self, String> {
        let mut handle: cublasHandle_t = std::ptr::null_mut();
        let result = unsafe { cublasCreate_v2(&mut handle) };
        
        if result == 0 {
            Ok(Self { handle })
        } else {
            Err(format!("cuBLAS initialization failed"))
        }
    }
    
    pub fn gemm(
        &self,
        m: i32,
        n: i32,
        k: i32,
        alpha: f32,
        a: &[f32],
        b: &[f32],
        beta: f32,
        c: &mut [f32],
    ) -> Result<(), String> {
        unsafe {
            let result = cublasSgemm_v2(
                self.handle,
                cublasOperation::CUBLAS_OP_N as i32,
                cublasOperation::CUBLAS_OP_N as i32,
                m, n, k,
                &alpha,
                a.as_ptr(), m,
                b.as_ptr(), k,
                &beta,
                c.as_mut_ptr(), m,
            );
            
            if result == 0 {
                Ok(())
            } else {
                Err(format!("cuBLAS gemm failed"))
            }
        }
    }
}

impl Drop for CublasHandle {
    fn drop(&mut self) {
        unsafe {
            cublasDestroy_v2(self.handle);
        }
    }
}
```

### bindgen ã«ã‚ˆã‚‹è‡ªå‹•ç”Ÿæˆ

æ‰‹å‹•ã§FFIå®šç¾©ã‚’æ›¸ãã®ã¯å¤§å¤‰ãªã®ã§ã€**bindgen**ã§è‡ªå‹•ç”Ÿæˆã—ã¾ã™ [^6]ï¼š

[^6]: bindgen: https://rust-lang.github.io/rust-bindgen/

```toml
# build.rs ã§ bindgen ã‚’å®Ÿè¡Œ
[build-dependencies]
bindgen = "0.69"
```

```rust
// build.rs
fn main() {
    println!("cargo:rerun-if-changed=wrapper.h");
    
    let bindings = bindgen::Builder::default()
        .header("wrapper.h")
        .clang_arg("-I/usr/local/cuda/include")
        .parse_callbacks(Box::new(bindgen::CargoCallbacks))
        .generate()
        .expect("Unable to generate bindings");
    
    bindings
        .write_to_file("src/bindings.rs")
        .expect("Couldn't write bindings!");
}
```

```c
// wrapper.h
#include <cuda_runtime.h>
#include <cublas_v2.h>
```

## 4.5 ã‚¼ãƒ­ã‚³ã‚¹ãƒˆæŠ½è±¡åŒ–ã¨ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚æœ€é©åŒ–

Rustã®**ã‚¼ãƒ­ã‚³ã‚¹ãƒˆæŠ½è±¡åŒ–**ã¯ã€ã€ŒæŠ½è±¡åŒ–ã‚’ä½¿ã£ã¦ã‚‚ã€æ‰‹æ›¸ãã®ä½ãƒ¬ãƒ™ãƒ«ã‚³ãƒ¼ãƒ‰ã¨åŒç­‰ã®æ€§èƒ½ã€ã‚’æ„å‘³ã—ã¾ã™ [^7]ã€‚

[^7]: Stroustrup, B. "Foundations of C++." ã‚¼ãƒ­ã‚³ã‚¹ãƒˆæŠ½è±¡åŒ–ã®æ¦‚å¿µã¯C++ã‹ã‚‰å¼•ãç¶™ãŒã‚Œã¦ã„ã¾ã™

### ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã®æœ€é©åŒ–

```rust
// é«˜ãƒ¬ãƒ™ãƒ«ã‚³ãƒ¼ãƒ‰
let sum: f64 = data.iter()
    .filter(|&&x| x > 0.0)
    .map(|&x| x * x)
    .sum();

// ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«å¾Œã¯ä»¥ä¸‹ã¨åŒç­‰ã®ãƒã‚·ãƒ³ã‚³ãƒ¼ãƒ‰ã«
let mut sum = 0.0;
for &x in data {
    if x > 0.0 {
        sum += x * x;
    }
}
```

**æ€§èƒ½æ¸¬å®š**:

| å®Ÿè£… | æ™‚é–“ï¼ˆ100ä¸‡è¦ç´ ï¼‰ | æœ€é©åŒ–å¾Œ |
|------|-----------------|---------|
| ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ãƒã‚§ãƒ¼ãƒ³ | 1.2 ms | SIMDã«è‡ªå‹•ãƒ™ã‚¯ãƒˆãƒ«åŒ– |
| æ‰‹æ›¸ããƒ«ãƒ¼ãƒ— | 1.2 ms | åŒä¸€ã®ãƒã‚·ãƒ³ã‚³ãƒ¼ãƒ‰ |

### ã‚¸ã‚§ãƒãƒªã‚¯ã‚¹ã¨å˜ç›¸åŒ–ï¼ˆMonomorphizationï¼‰

```rust
// ã‚¸ã‚§ãƒãƒªãƒƒã‚¯é–¢æ•°
fn add<T: std::ops::Add<Output = T>>(a: T, b: T) -> T {
    a + b
}

// ä½¿ç”¨æ™‚
let x = add(1i32, 2i32);      // i32ç‰ˆãŒç”Ÿæˆ
let y = add(1.0f64, 2.0f64);  // f64ç‰ˆãŒç”Ÿæˆ
```

ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã¯**å‹ã”ã¨ã«å°‚ç”¨ã®ã‚³ãƒ¼ãƒ‰**ã‚’ç”Ÿæˆã™ã‚‹ãŸã‚ã€å®Ÿè¡Œæ™‚ã®ã‚ªãƒ¼ãƒãƒ¼ãƒ˜ãƒƒãƒ‰ã¯ã‚¼ãƒ­ã§ã™ã€‚

### const fn ã«ã‚ˆã‚‹å®šæ•°ç•³ã¿è¾¼ã¿

```rust
const fn factorial(n: u64) -> u64 {
    match n {
        0 | 1 => 1,
        _ => n * factorial(n - 1),
    }
}

// ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã«è¨ˆç®—ã•ã‚Œã‚‹
const FACT_10: u64 = factorial(10);  // 3628800

fn main() {
    // å®Ÿè¡Œæ™‚ã«ã¯ãŸã ã®å®šæ•°ã‚¢ã‚¯ã‚»ã‚¹
    println!("{}", FACT_10);
}
```

### inline æœ€é©åŒ–

```rust
// å¸¸ã«ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³åŒ–
#[inline(always)]
fn dot_product(a: &[f64], b: &[f64]) -> f64 {
    a.iter().zip(b).map(|(x, y)| x * y).sum()
}

// ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã«ä»»ã›ã‚‹ï¼ˆæ¨å¥¨ï¼‰
#[inline]
fn matrix_multiply(a: &[f64], b: &[f64], n: usize) -> Vec<f64> {
    // ...
}

// ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³åŒ–ã—ãªã„
#[inline(never)]
fn debug_print(msg: &str) {
    println!("{}", msg);
}
```

### SIMD ã¨è‡ªå‹•ãƒ™ã‚¯ãƒˆãƒ«åŒ–

```rust
// portable_simd ã‚’ä½¿ç”¨ï¼ˆnightlyï¼‰
#![feature(portable_simd)]
use std::simd::*;

fn simd_add(a: &[f32], b: &[f32], c: &mut [f32]) {
    assert_eq!(a.len(), b.len());
    assert_eq!(a.len(), c.len());
    
    let lanes = f32x8::LEN;
    let (a_chunks, a_remainder) = a.as_chunks::<8>();
    let (b_chunks, b_remainder) = b.as_chunks::<8>();
    let (c_chunks, c_remainder) = c.as_chunks_mut::<8>();
    
    for ((a_chunk, b_chunk), c_chunk) in a_chunks.iter()
        .zip(b_chunks)
        .zip(c_chunks) {
        let a_simd = f32x8::from_array(*a_chunk);
        let b_simd = f32x8::from_array(*b_chunk);
        let c_simd = a_simd + b_simd;
        *c_chunk = c_simd.to_array();
    }
    
    // æ®‹ã‚Šã®è¦ç´ ã‚’å‡¦ç†
    for i in 0..a_remainder.len() {
        c_remainder[i] = a_remainder[i] + b_remainder[i];
    }
}
```

### ã¾ã¨ã‚ï¼šPythonã¨ã®æ€§èƒ½å·®

| æ©Ÿèƒ½ | Python | Rust |
|------|--------|------|
| ãƒ«ãƒ¼ãƒ— | ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ—ãƒªã‚¿å®Ÿè¡Œ | ãƒã‚¤ãƒ†ã‚£ãƒ–ã‚³ãƒ¼ãƒ‰ |
| é–¢æ•°å‘¼ã³å‡ºã— | å‹•çš„ãƒ‡ã‚£ã‚¹ãƒ‘ãƒƒãƒ | é™çš„ãƒ‡ã‚£ã‚¹ãƒ‘ãƒƒãƒ + ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³åŒ– |
| ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ | å®Ÿè¡Œæ™‚ã‚ªãƒ¼ãƒãƒ¼ãƒ˜ãƒƒãƒ‰ | ã‚¼ãƒ­ã‚³ã‚¹ãƒˆï¼ˆæœ€é©åŒ–å¾Œæ¶ˆå¤±ï¼‰ |
| ã‚¸ã‚§ãƒãƒªã‚¯ã‚¹ | ãƒ€ãƒƒã‚¯ã‚¿ã‚¤ãƒ”ãƒ³ã‚° | å˜ç›¸åŒ–ï¼ˆå‹ã”ã¨ã«æœ€é©åŒ–ï¼‰ |
| SIMD | NumPyã®Cå®Ÿè£…ã«ä¾å­˜ | è‡ªå‹•ãƒ™ã‚¯ãƒˆãƒ«åŒ– or æ˜ç¤ºçš„SIMD |

**å®Ÿæ¸¬ä¾‹**ï¼ˆ1å„„è¦ç´ ã®é…åˆ—æ¼”ç®—ï¼‰:

| å®Ÿè£… | æ™‚é–“ |
|------|------|
| Pythonï¼ˆç´”ç²‹ï¼‰ | 2500 ms |
| NumPy | 25 ms |
| Rustï¼ˆç´ æœ´ï¼‰ | 50 ms |
| Rustï¼ˆæœ€é©åŒ–ï¼‰ | 20 ms |
| Rustï¼ˆSIMDï¼‰ | 12 ms |

æ¬¡ç« ã§ã¯ã€ã“ã‚Œã‚‰ã®åŸºç¤ã‚’æ´»ã‹ã—ã¦ã€ä¸¦åˆ—è¨ˆç®—ã¨éåŒæœŸå‡¦ç†ã‚’å­¦ã³ã¾ã™ã€‚
---

[ğŸ“š ç›®æ¬¡ã«æˆ»ã‚‹](../README.md) | [â¬…ï¸ ç¬¬3ç« : è‡ªå‹•å¾®åˆ†ã®ä»•çµ„ã¿](../01_ç¬¬Iéƒ¨_åŸºç¤ç†è«–ã¨å…¨ä½“åƒ/01-03-è‡ªå‹•å¾®åˆ†ã®ä»•çµ„ã¿.md) | [â¡ï¸ ç¬¬5ç« : ä¸¦åˆ—è¨ˆç®—ã¨éåŒæœŸå‡¦ç†](02-05-ä¸¦åˆ—è¨ˆç®—ã¨éåŒæœŸå‡¦ç†.md)